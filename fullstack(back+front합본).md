# frontend

[기본 CS지식은 위 링크에서 정리가 잘되어 있으니 한번 읽고서부터 아래를 읽어보도록하자](https://mangkyu.tistory.com/88) 

##### FRONTEND

  
#### HTML 
  - 이벤트의 발생은 하위 -> 상위로 발생(이벤트버블링)하고, 
  - 이벤트의 탐색은 상위 -> 하위로 (이벤트캡쳐링) 트리구조로 이루어져 있다. 이를 이벤트 위임이라고한다. 
  - 이 두가지가 상위 하위 이벤트핸들링하는 방법이다.
  - 기본적으로 뷰는 실행컨텍스트로 이루어지는데 전역컨텍스트가 한개 만들어지면 그 안에 함수컨텍스트들로 이루어진다.
  - XHTML과 HTML이 있는데 JSX처럼 확장된 언어이다. 조금 더 엄격한 규칙이 적용되어져 있다. 
  - 파일 초반에 HTML DOCTYPE 을 선언해서 markdown 언어에 대한 설정을 한다. 
  - Lazy Loading을 통하여 CSR의 이점을 챙겨온다. ( 초기에 렌더링을 하여서 메모리 효율적 관리 ) 
```
-HTML 동작원리
1. 사용자가 특정 웹사이트를 도메인을 입력한다.
2. 도메인이 입력되면 DNS서버에서 해당 도메인에 맞는 ip를 가져온다.
3. 결과 값으로 HTML 파일이 나오면 웹 브라우저는 해당 HTML을 파싱한다.
4. 파싱한후에 DOM 트리를 만들어 나간다. 
5. DOM트리가 완성되면 CSS를 파싱해주며, 사이트의 뷰를 띄워준다.
```

- 중간중간 JS를 만나면 제어권한을 넘기고 JS를 파싱하고 실행하는 과정이 있다.
- 보통의 대형 서비스는 서버가 하나터지면 대체서버를 바로 사용하는 무중단배포가 있다.
- 기본적으로 아래와 같은 구조로 이루어져 있다.

![image](https://media.vlpt.us/images/araaaaan/post/b99d2d54-fb43-4cc1-be09-2b9c3f6f6782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.35.26.png)
- 웹서버 : 주로 정적인 데이터 처리를 한다. 사용자에게 뿌려지는 뷰나 사용자에게 받는 정적인 데이터들을 저장 및 관리를 한다.
- 웹애플리케이션서버 : 주로 동적인 데이터 처리를 한다. DB에 관련된 내용에대해서 CRUD가 이루어지거나, SQL MAPPER나 ORM을 이용한다. 
- 이 두개를 따로 사용하는 이유는 서버의 과부하를 막기 위해서 사용되는 목적이다.

#### Webpack & Babel
  - Webpack
    - 자바스크립트는 모듈을 지원하지 않기 때문에, 모듈 설치 패키지라고 생각하면 된다. 
    - 패키지매니저로는 npm과 yarn이 있다. 버전을 맞춰주려 yarn을 주로 사용했지만 요즘에는 npm에도 package를 해주기 때문에 어떤걸 사용해도 된다. 
    - Dependencies 와 devDependenices 가 있는데 이는 환경에 필요한 패키지 / 테스트와개발에 필요한 패키지 두개의 차이가 있다. 
  - Babel 
    - 버전을 맞춰주는 기술이다. ES6에서 나온 문법이며, ES6를 기준으로 코딩을해도 ES5로 변환을 해준다. 

#### Ajax 
- 클라이언트에서 직접적인 접근없이 http 통신 규약을 사용하여 서버에서 데이터를 받아오는 기술 
- 받아오는 데이터는 JSON/XML 두가지로 받아올 수 있다. 
  - JSON: XML보다 사용자가 조금 더 직관적으로 볼 수 있는 데이터 구조, 데이터의 형태는 정해져있으며 모듈설치없이 문자열로 받아올 수 있다.
  - XML: 계층적인 구조로 return을 받는 데이터 구조, 데이터 형태가 자유로우며 xml 파싱 모듈이 있어야만 데이터를 받아올 수 있다. 
- REST API 구조를 이루고 있다.
  - RESTAPI : SQL조건문등을 사용하지 않고 URI에 필요한 명령어를 입력하고 method를 요청하여 원하는 데이터를 받거나 정정할 수 있는 것.
- 기본적인 통신 스택은로는 ajax, axios, fetch가있다. 
```
-ajax: 기본적으로 jQuery 기반으로하는 데이터 송/수신구조이다. promise 객체가 아닌 콜백구조이다.
-axios: 모듈을 설치해야하는 데이터 송/수신 구조이다. nodeJS기반으로 작업을 할 시에 일관성에 효과를 줄 수 있다.
-fetch: JS에 기본적으로 내장되어 있는 데이터 송/수신 구조이다. promise 객체이다. 

    - promise 
    대기(pending) : 아직 실행되지 않은 초기 상태
    이행(fulfilled) : 작업이 성공적으로 완료됨.
    거부(rejected) : 작업이 실패함.
    
    작업이 성공적으로 이행이 되었거나, 실패 했을 때, 어떠한 작업을 해야 하는데 이 작업은 then 메소드에 의해 실행된다. 
    이는 callback함수를 실행한 것과 같은 효과를 낸다. then 메소드는 promise객체에 붙여서 사용한다.
    promise가 너무 복잡하게 체이닝(chaning)되면 async ~ await()을 사용하여 코드를 간결하게 해줄 수 있다.
    이를 사용하면, promise ~ then 구조로 작성을하지 않아도 된다. (대기 -> 이행 & 거부를 다 기다려줌)
    
    promise.all(함수1,함수2) 을 사용하면 비동기적 병렬처리가 가능하다
    promise.race(함수1,함수2) 을 사용하면 비동기적 처리중 가장 먼저온것을 출력하고 종료시킬수 있다.

```
 
#### AMP
- 웹페이지의 빠른 렌더링을 위한 캐시 기술스택이다. 
- 모든 외부 JS파일들은 비동기로 처리한다. 

#### CSS vs SCSS,Sass 
  - CSS에서의 접근연산자 > , :not 등을 조금 더 보기 쉽게 작성할 수 있는 CSS문법이라고 생각하면된다.
  - SCSS는 중괄호 {} , Sass는 세미콜론 ; 으로 문맥을 구분한다.

#### inline vs block 
  - 둘다 CSS 문법이다. <span/>이 예시로 둘 수 있다.  
  - inline은 margin이나 padding에 대한 값의 변동을 적용하는대에 제한이 있다.
  - Block은 자유롭게 설정할 수 있다.
  - Block에 inline을 적용하고 싶으면 inline-block 선언을 해주면 된다. 

#### import vs require 
  - require는 ES6전 라이브러리를 호출할 때 사용하는 문법이였다. 
  - 두 개의 의미는 같이 사용되지만 만약 NodeJS에서 Babel을 사용하지 않을 경우에는 require를 사용해주어야 한다. 

#### JAVASCRIPT 
  - 자바스크립트는 유저의 편의성을 위해 짧은 시간만에 개발된 동적 언어이다.
  - 짧은 시간에 나왔기에, ES6 표준안이 나오기전까지는 여러 이슈가 많았다. (var 변수 사용을 통한이슈)
  - 배열 구조는 실제 자료구조 배열이 아닌 HashMap으로 구현되어있다. 
    - 그 이유는 정적인언어 C,C++,JAVA 등과 다르기에 동적으로 메모리할당을 더 효율적으로 하기 위해서이다. 
  - 그렇기에 다른 언어와 다르게 class기반이 아닌 prototype 기반으로 virtual DOM에 렌더후 사용자 DOM에 렌더해준다. 
  - 이는 단일스레드 언어이며, 앱 워커를 사용하여 멀티스레드 구현도 가능하다. 
  ```
  - 단일스레드에서의 이벤트 루프 & 버블링 (동작원리)
    - 기본적으로 단일스레드에서는 스택을 통해서 한줄씩 작업을 관리하며 동기적&비동기적으로 순서가 정해진다.
      (기본적으로는 스택에 있는 명령을 처리하는 동기적구조이다.)
    - 즉 setTimeout()을 걸어도, 그 부분을 기다리고 다시 시작이 아닌, 다 실행후에 setTimeout()을 실행한다.
    - 스택을 너무 무분별하게 사용하거나 (시간복잡도가 엄청많거나) 이벤트를 너무 많이 사용하면 (큐 과부하) 사이트가 마비된다.
    
    1. 이 원리는 각 Task를 스택 안에서 명령을 실행하고 힙 안에서 변수를 선언한다. 
    2. 단 스택안에서 처리가 오래걸리는 비동기/시간/이벤트리스너 관련된 명령어는 큐(일반)에 따로 보내둔다.
    3. 스택에 명령이 끝나면(empty) 큐(대기실)에 다시 보내서, 스택으로 하나씩 올려보낸다.
                                                                                                        (아래 이미지 참조)
  ```
  ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdZ8YBt%2FbtqwhxzE1py%2FRQNPdMhyWbLZ3zDAptsVhK%2Fimg.png)
 
  ![image](https://blog.kakaocdn.net/dn/c7OXFt/btqwhUVuXGv/rYhxWO3UOuPePPe2nVL3P1/img.gif)
  - 원시타입의 종류로는 null,undefined,number,string,boolean,object가 있다. 
  - 선언되는 위치에 따라서는 클로져(clouser)가, 호출하는 방법에 따라서는 this를 기억하자. 
  ```
  This 정의
    - 자신이 속한 객체에서 인스턴스를 가르킬때 사용한다.
    - bind,call,apply를 사용하여 핸들링 할 수 있다.
      bind : 새로운 것을 가르키는데 사용.
      call : this에 바인딩 된 것을 호출하는데 사용.
      apply : this에 바인딩을 시켜주는데 사용.
    - 전역에서는 window를 가르키기 때문에 애로우함수내에서 this를 선언해주거나 new를 통해서 생성자에 this를 바인드 해주자. 
    - strict모드에서는 this가 window가 아닌 strict를 가르킨다.
              cf) strict mode
              ES5에 나온 제한된 모드를 선언하는 것이고, 데이터를 read only만 가능하다.
              가볍게 넘기던 warning이나 문법적 오류를 전부다 검사를 해주는 모드이다. 
  ```
    - 기본적인 함수들은 대부분 ES6에서 생성이 되었다. (import,arrow function,spread,const&let,promise 등)
#### JAVASCRIPT CLOSURE 
  - 원하는 시점에서 내부 클로저를 실행할 수 있다. 
  - 즉 부모클래스나 메소드에서 상속된 자식 클래스나 메소드를 접근할 때에 부모 클래스로 변수가 선언되어도 내부로 접근이 가능하다.
  - 이를 스코프체인이라고도 한다. 

#### JAVASCRIPT HOISTING
  - 함수안에 있는 선언들을 모두 끌어올려서 유효 범위의 최상단으로 선언하게 해주는것이다.
  - 메모리적으로 변화는 없으며 var 변수 선언과 함수선언문에서만 호이스팅이 발생한다.
  - 변수의 선언과 대입을 두가지로 나뉘어서 선언을 최상단 스코프에서 실행해준다.
  - 함수내에서 변수형태를 선언하지않고 실행하면 자동으로 전역변수로 선언이된다. 
      예시:
      ```Javascript
      console.log(name);//undefined
      a();
      function a(){
      name = 'bang';
      }
      console.log(name);//bang
      ```
      
      ```Javascript
      console.log(name);//bang
      a();
      function a(){
      var name = 'bang';
      }
      console.log(name);//bang
      ```
      


#### JAVASCRIPT Throw&Try ~ catch ~ finally 
- try~catch~finally 에서 비동기처리를 한번 더 시행을 하면, 오류를 잡아 낼 수 없다. 그렇기에 한번 더 try catch문을 안에 작성해주어야한다.   
  (예시: try문에 setTimeout()이 있다면 해당 부분은 오류를 잡지못해서 setTimeout()안에 한번 더 try catch문을 선언해주어야함) 
- Promise객체에 대해서는 async ~ await을 사용해야만 에러 헨들링 처리를 할 수 있다. 
- Throw: 예외처리를 위한 명령어이다. 아래에 예시를 기재했다.
- try: 무언가를 시도하는 구문 try가 정상적으로 되면 catch문에 접근하지 않으며, 에러가 생길시에는 try를 멈추고 catch로 넘어간다.
- catch(e): 특정에러가 발생했을때 접근하는 구문 에러에 대한 정보는 e parameter에 들어가 있다. 
- finally: try와 catch이후에 실행되는 구문, 보통 몇번의 로직이 돌았는지, true/false 값을 상관안하고 핸들링 처리할 때 사용한다.
```Javascript
function factorial(x) 
{
// 만약 전달인자가 유효하지 않으면 예외를 발생시킨다!!! 
if (x < 0) {
throw new Error('x는 음수가 아니어야 합니다.') } // 유효하다면 값을 계산하여 정상적으로 반환환다. 
for (var f = 1; x > 1; f *= x, x--) /* 비어 있음 */
return f;
}

try { 
/** 
* 정상이라면 이 코드는 아무런 문제없이 블록의 시작부터 끝까지 실행된다.
* 하지만 경우에 따라 예외가 발생할 수 있다.
* 예외는 throw 문에 의해 직접적으로 발생할 수도 있고, 
* 또는 예외를 발생시키는 메서드의 호출에 의해 발생할 수도 있다.
*/
}
catch (e) {
/** 
* 이 블록 내부의 문장들은 오직 try 블록에서 예외가 발생할 경우에만 실행된다.
* 이 문장들에선 지역 변수 e를 사용하여 Error 객체 또는 앞에서 던진 다른 값을 참조할 수 있다. 
* 이 블록에서는 어떻게든 그 예외를 처리할 수도 있고, 
* 그냥 아무것도 하지 않고 예외를 무시할 수도 있고,
* 아니면 throw 를 사용해서 예외를 다시 발생시킬 수도 있다. 
*/ 
}
finally {
/** 
* 이 블록에는 try 블록에서 일어난 일에 관계없이 무조건 실행될 코드가 위치한다. 
* 이 코드는 try 블록이 어떻게든 종료되면 실행된다.
* try 블록이 종료되는 상황은 다음과 같다.
* 1) 정상적으로 블록의 끝에 도달했을 때
* 2) break, continue 또는 return 문에 의해서 
* 3) 예외가 발생했지만 catch 절에서 처리했을 때
* 4) 예외가 발생했고 그것이 잡히지 않은 채 퍼져나갈 때 
*/
}
```
#### JAVASCRIPT Eslint 
 - 소스코드를 스캔하여서 잠재적 오류를 찾아내는 디버깅 도구 

#### JAVASCRIPT GARBAGE COLLECTOR
- 참조된 값을 사용하고 더이상 참조되는 값에 대해서 사용하지 않거나, 메모리 할당을 시행하고 더 이상 사용하지 않을때    
      자체적으로 메모리 할당을 해제하여 메모리를 관리해주는 것 
- 사용자가 강제적으로 실행 종료를 할 수 없다. 

#### JAVASCRIPT Promise 
- 초기 콜백함수에 대한 대처 기술로 나왔다. (계속해서 콜백을 할 경우 로직이 복잡해지고 보수가 어려워지기 때문에)
- 하지만 Promise만 사용할 경우에는 then이 콜백처럼 엄청 사용해야 하기때문에 복잡한 부분이 있었다.
- 비동기 통신에 시작, 발목을 잡을수도 도움을 줄수도 있는 객체 형태이다.
- 말그대로 약속을 해주는 개체이기에 이 일을 처리해줄게 ~ 라는 의미를 가진다.
- async ~ await() 을 같이 사용하지 않으면 promise가 종종 비어있는 객체로 받아져서 JSON.parse()를해도 원하는 값을 받지 못할 수 있다.
- async ~ await() 이 생기면서 fetch() ~ then()의 복잡한 구문을 줄여 줄 수 있게 되었다. 
- 위에서 언급한것처럼 try~catch문에서 promise만 사용할 경우에 promise도 객체 취급을 받기 때문에 에러 핸들링 처리가 번거롭다. 

#### Restful API 
- 클라이언트와 서버사이에 URI링크에 필요한 정보와 요청할 정보를 담아서 데이터를 주고받는 기술 
- 과거의 SOAP의 복잡함을 해결해주는 기술이다. 
- 기능만이 아닌 가독성과 효율성을 위해서 나온것이다.
- 주소만으로 무엇을하는 것인지 알 수 있다. (URI = 행위 , method = CRUD를 포함하기 때문에)
#### JQUERY 
- 조금 더 효율적으로 JS를 사용할 수 있는 JS 라이브러리이다. 
- detach() , remove() : 삭제하고 잔여물 남기기 / 삭제하고 잔여물도 없애기 
- .min.js로 경량화작업이 가능하다. 
- onload() , document.ready() : 객체가 모두 표시된후 호출 / DOM이 생성시에 바로 호출 

#### REACT 
- 클래스형과 함수형 구조로 만들수 있다. 
```
클래스형 - 
1. 컴포넌트를 상속 받아사용할때 this.pros; 구문을 사용하여서 변수에 접근할 수 있다. 
2. 애로우 함수와 this를 합쳐서 사용해야 한다. 
3. useState 없이 this로 선언을해도 값에 대한 렌더가 가능하다. (render함수가 있기 때문에)

함수형 - 
1. 컴포넌트를 상속 받아사용할때 바로 접근하여 사용할 수 있다. 
2. const + function() 형태로 합쳐서 사용해야 한다. 
3. useState를 사용해서 값에 변동을 체크해야 값에 대한 렌더가 가능하다. (render함수가 없기 때문에)

```
#### React Hooks 
  - 함수형구조에서 클래스형구조에 장점을 사용하기 위해서 나온 기술이다.
  - useState, useEffect 등을 사용하여서 상태관리를해주어 라이프싸이클 메소드를 사용한다. 
  - 라이프싸이클 메소드란 리액트에 돔트리라이프 싸이클 구조를 의미한다. 
  - this로 상태를 관리하는 것보다 코드의 경량화가 가능하며 재사용성을 높여준다. 
  - Hooks가 나와도 컴포넌트구조와 함께 같이 사용한다. 


![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeceuwJ%2FbtqF7ED8WpX%2FQTATE8lUtpkC09UkB85tG0%2Fimg.jpg)
```
-DomTree LifeCycle 
- 큰 구조로는 componentDidMount(초기화) -> componentDidUpdate(업데이트) -> componentWillunMount(소멸) 구조로 이루어진다.
- componentDidMount : Hook 개념이나 초기 렌더가 이루어지는 곳 
- componentDidUpdate : 성능최적화를 하는 구문이며, 값에 대한 업데이트를 해주는 곳 (Hooks에 의한 상태변환)
- componentWillunMount : 소멸단계, 자원의 해체가 이루어지는 곳이다. 

초기화 단계에서는 useMemo()  
업데이트 단계에서는 useState()
모든 단계에서는 useEffect()가 우선 순위를 가진다. 
```


#### React vs Vue 
  - 앵귤러는 typescript 기반이기에 처음부터 러닝커브가 높아서 논외로 하고 이야기하고자 한다
  - React는 Vue에 비해서 구조가 조금 더 재사용성이 뚜렷하다.
  - 하지만 Vue에서는 HTML,CSS,JS 파일을 나누어서 작업할 수 있으며 라이브러리와 템플릿 지원이 조금더 효율적이다.
  - 자료량은 React가 더 많다. 
  - 현재에는 React나 Vue나 참고자료나 라이브러리가 둘다 많기에 어떤걸 사용해도 괜찮다. 둘다 virtual DOM을 사용한다.
  - 코드의 재사용성은 React가 우수하다. Hooks의 개념으로 값을 업데이트하면 덮어씌울수 있지만 Vue에서는 계속해서 객체를 만들어주어야 한다.


* * * 

# backend


##### BACKEND

#### JAVA 
  - OOP(객체지향성)이 강한 언어 객체 지향성에 장점으로는 다형성, 캡슐화, 상속성, 추상화가 있다. 
    ```
    - 다형성: extends의 개념, 부모 클래스와 부모 클래스를 기반으로 하는 자식 클래스를 만들면,                     
             부모 클래스에서 자식 클래스를 선언할 수 있지만 자식 클래스는 부모 클래스에서 선언 불가능 = 오버로딩,오버라이딩 개념 
              - 오버로딩 : 메소드(함수)명이 같아도 매개변수나 타입이다르면 사용할 수 있다.
              - 오버라이딩 : 메소드(함수),매개변수,타입이 같다. 단, 부모 클래스와 자식 클래스 관계이여야하며,      
              자식클래스에선 자식클래스가 실행된다.
    - 캡슐화: 데이터 구조와 데이터 로직을 묶어서 표현한 것 ( 외부접근 불가하게함 ) 
    - 상속성: 상위 개념을 하위 개념이 물려 받는것 ( 자동차에서 스포츠카를 만든다. 자동차가 기본베이스 이를 상속이라 한다.)
    - 추상화: 공통의 기능을 묶어서 이름을 표기한 것 ( 강아지 + 고양이 = 동물 )
    ```
  - 이는 객체지향성 5대원칙 SOLID를 준수한다.
    ```
    - S : 단일 책임원칙 ( 객체는 단 하나의 책임만 가져야 한다. )
    - O : 개방-폐쇄원칙 ( 기존의 코드를 변경하지 않으면서, 기능을 추가해야 한다. )
    - L : 리스코프 치환 원칙 ( 자식 클래스는 부모 클래스에서 가능한 행위를 해야한다. )
    - I : 의존 역전 원칙 ( 변화가 잦은것보다 변화가 없는 것에 의존하라. )
    - D : 인터페이스 분리 원칙 ( 인터페이스를 클리언트에 특화되도록 분리시켜야 한다. )
    ```
    - 사실상 이 원칙이 무시되면 절차지향프로그래밍과 다를게 없다. OOP에 4가지 특성을 말하면서,                 
        그 원칙이 지켜지면 SOLID를 준수한다라고 말하면 될듯.
  - JVM 위에서 돌아가기 때문에 운영체제 독립적이며, 자동으로 메모리를 관리해준다. 
    - JVM은 메서드 , 힙 , 스택 영역으로 이루어져 있다. 
    - 스택에 있는 데이터를 바이트화(Byte)시키는 직렬화로 이루어져있다.
  - 그렇기에 멀티스레드를 컴퓨터 사양에 상관안하고 구현할 수 있다.
  - 프로그램 실행시, 전체 실행이 아닌 필요한 부분만 실행되기 때문에 동적 로딩을 지원한다.
  - 운영체제위에 VM을 통해서 실행되기에, 속도가 느리며 예외처리를 직접선언을 해주어야 한다. (try~catch)
  - c++과는 다르게, JAVA는 컴파일 후에 jar파일로 압축되고, c++은 컴파일 후에 링크가 된다.     
         (visual studio에서 .cpp파일을 링크시키는개념)
 
  ```
  -클래스 : 객체를 만들기 위한 기본적인 틀 (변수+메소드) 
    -메소드는 함수라고 생각하면 된다.
  -객체 : 구현할 대상이다. 클래스의 인스턴스라고 불리우며, 모든 인스턴스의 모임이다.
  -인스턴스 : 구현할 구체적인 실체이다. 변수들이 모여 인스턴스를 이룰 수 있으며, 여러과정도 인스턴스라고 불리운다.    
              이를 생성된 복제본이라고도 한다. (new 생성자같은 것)
  ```
  - 이를 단계로 나누는 것을 추상화 기법이라고한다.
    - 분류 : 객체 -> 클래스 
    - 인스턴스화 : 클래스 -> 인스턴스화 
  ``` 
  JAVA의 변수 기능들 
  String : String에서 저장되는 문자열은 바꿀 수 없다. 하지만 Stack에 쌓이며, 가비지 콜렉터가 호출되기 전까지는      
            메모리가 굉장히 비효율적으로 사용되므로 직섭생성이아닌 append 형식으로 아래의 기능을 활용하자. 
  StringBuffer : 동기식 문자열처리 -> 동기식 처리를 하기에 조금 더 안전하다.
  StringBulider : 비동기식 문자열처리
        - 비동기식 : 호출이 되면 비동기구분을 먼저 실행을 하고 끝나면 다시 순서대로 실행되는 것 
        - 동기식 : 코드가 작성된 순서대로 실행되는 것 
  
  Public : 접근제한이 없음
  Private : 자기 자신의 클래스만 접근이 가능 접근이 원하면 메소드를 만들어라 
  Protected : 파생 클래스나 같은 패키지에서만 사용 가능 
  default : 아무 선언을 안하는 것을 칭하며, 같은 패키지에서만 사용가능 
  ```
  ```
  Type        Bits      Range of Values
----------------------------------------------------------------------------------------
byte         8bits    -2^7 ~ 2^7-1 (-128 ~ 127)
short       16bits    -2^15 ~ 2^15-1 (-32768 ~ 32767)
int         32bits    -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647)
long        64bits    -2^63 ~ 2^63-1 (-9223372036854775808 ~ 9223372036854775807)
float       32bits    0x0.000002P-126f ~ 0x1.fffffeP+127f
double      64bits    0x0.0000000000001P-1022 ~ 0x1.fffffffffffffP+1023  
char        16bits    \u0000 ~ \uffff (0 ~ 2^15-1) * 자바에서 unsgined로 동작하는 자료형
boolean      1bit     true, false
8Bits = 1Byte
  ```
  
  ##### Reflection 
  - 다른 객체지향 언어에서는 볼 수 없는 기능, 이미 로딩이 완료된 클래스에서 다른 클래스를 동적 로딩을 하여, 사용하는 것이다.
  - 구체적인 타입을 모르더라도, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해준다.
  - Spring에서 어노테이션(@)의 기능과 같다. 힙 영역에 있는 클래스 정보를 가져올 수 있다.
  - 이를 사용할 때에 private 멤버도 접근이 될 수 있으니 사용할 때는 주의하면서 사용하자.
  - 이가 나온 이유는 동적언어인 JS,Python 과 다르게 정적언어인 C,C++,Java의 문제를 해결하기 위해서 이다.

  ##### equals vs == 
  ![image](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F1137EB394D6B4A4017)
  - eqauls는 주소값 자체를 비교한다. 즉 생성자로 변수 값은 같은 변수를 만들어도 주소가 다르기에 false가 나온다. 
  - ==은 내용 자체를 비교한다.
  
  ##### Static vs Non-static 
  - 정적변수와 동적 변수에 차이이다.
  - static을 선언하면 메서드 영역으로 변수가 들어가서 누적된 값을 호출할 수 있다. 
  
  ##### Call by Reference vs Call by Value 
  - Call by Value (값에 의한 호출)
    - 자바의 기본형이다. 참조형으로는 함수에 의한 호출이라고 하지만, 기본적으로 인자를 넘길때 값을 넘겨 복사가 된다.
    - 값을 부르기에 호출시에 메모리의 임시공간이 생성후 복사된다.
    - 불러진 곳에서 변수를 변경하면, 값이 복사 된 것이기에 변동되지 않는다.
  - Call by Reference (함수에 의한 호출)
    - 기본적인 포인터의 개념이다.
    - 값이 변동되면 함께 변동이 된다. 
  ##### Abstract Class vs Interface 
   - Abstartct Class
    - 한 개의 추상 메서드가 있으면 무조건 Absract를 선언해야하며, 모든 추상 메서드를 오버라이딩 가능해야 한다.
      - 반대로 메서드가 없으면 선언해도 되고 안해도 된다. 
    - 인스턴스 생성 목적이 아닌, 부모클래스 활용목적이다.
    - 단일 상속을 위해서 사용한다.  
    - 상속받은 클래스의 기능 확장.

   - Interface 
    - 기본적인 뼈대를 만들어준다 생각하면 된다. 
    - 의존성을 많이 줄여줄 수 있다. 
    - 다중 상속을 위해서 사용한다.
    - 상속받은 클래스의 기능 동일. (확장보다는 기본뼈대를 넣어줄때 사용)
    
#### FRAMEWORK
- NODE
  - ![img](https://blog.kakaocdn.net/dn/bcKQfy/btqF3GWwNSK/lGEBlvgtKoA51YK1clMue1/img.gif)
  - 단순 CPU작업만을 사용하는대에 유리하다. 싱글스레드에서는 노드가 더 빠른 속도를 보인다.
  - 자바스크립트 기반이기에 프론트엔드 개발자가 배우기에 러닝커브가 낮을 수 있다.
  - 자바스크립트의 언어적 특성(타입세이프)때문에 서비스가 커지면 런타임이 걸릴 수 있고 에러 찾기가 힘들다.
- SPRING
  - ![img](https://blog.kakaocdn.net/dn/bsDJqc/btqF4zic8Zz/h3wrLJ0Hc8kNKKwWnM2Ckk/img.gif)
  - JAVA 기반에 프레임워크. 
  - 설정이 복잡하지만, 스레드처리면에서는 노드보다 우수하다.
  - 스레드처리를 하기위해 메모리를 많이 사용하다보니 부담이 많이 갈 수 있다.

  
