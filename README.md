# CS-study

##### BACKEND

#### JAVA 
  - OOP(객체지향성)이 강한 언어 객체 지향성에 장점으로는 다형성, 캡슐화, 상속성, 추상화가 있다. 
    ```
    - 다형성: extends의 개념, 부모 클래스와 부모 클래스를 기반으로 하는 자식 클래스를 만들면,                     
             부모 클래스에서 자식 클래스를 선언할 수 있지만 자식 클래스는 부모 클래스에서 선언 불가능 = 오버로딩,오버라이딩 개념 
              - 오버로딩 : 메소드(함수)명이 같아도 매개변수나 타입이다르면 사용할 수 있다.
              - 오버라이딩 : 메소드(함수),매개변수,타입이 같다. 단, 부모 클래스와 자식 클래스 관계이여야하며,      
              자식클래스에선 자식클래스가 실행된다.
    - 캡슐화: 데이터 구조와 데이터 로직을 묶어서 표현한 것 ( 외부접근 불가하게함 ) 
    - 상속성: 상위 개념을 하위 개념이 물려 받는것 ( 자동차에서 스포츠카를 만든다. 자동차가 기본베이스 이를 상속이라 한다.)
    - 추상화: 공통의 기능을 묶어서 이름을 표기한 것 ( 강아지 + 고양이 = 동물 )
    ```
  - 이는 객체지향성 5대원칙 SOLID를 준수한다.
    ```
    - S : 단일 책임원칙 ( 객체는 단 하나의 책임만 가져야 한다. )
    - O : 개방-폐쇄원칙 ( 기존의 코드를 변경하지 않으면서, 기능을 추가해야 한다. )
    - L : 리스코프 치환 원칙 ( 자식 클래스는 부모 클래스에서 가능한 행위를 해야한다. )
    - I : 의존 역전 원칙 ( 변화가 잦은것보다 변화가 없는 것에 의존하라. )
    - D : 인터페이스 분리 원칙 ( 인터페이스를 클리언트에 특화되도록 분리시켜야 한다. )
    ```
    - 사실상 이 원칙이 무시되면 절차지향프로그래밍과 다를게 없다. OOP에 4가지 특성을 말하면서,                 
        그 원칙이 지켜지면 SOLID를 준수한다라고 말하면 될듯.
  - JVM 위에서 돌아가기 때문에 운영체제 독립적이며, 자동으로 메모리를 관리해준다. 
    - JVM은 메서드(정적) , 힙 , 스택(동적) 영역으로 이루어져 있다. 
  - 그렇기에 멀티스레드를 컴퓨터 사양에 상관안하고 구현할 수 있다.
  - 프로그램 실행시, 전체 실행이 아닌 필요한 부분만 실행되기 때문에 동적 로딩을 지원한다.
  - 운영체제위에 VM을 통해서 실행되기에, 속도가 느리며 예외처리를 직접선언을 해주어야 한다. (try~catch)
  - c++과는 다르게, JAVA는 컴파일 후에 jar파일로 압축되고, c++은 컴파일 후에 링크가 된다.     
         (visual studio에서 .cpp파일을 링크시키는개념)
 
  ```
  -클래스 : 객체를 만들기 위한 기본적인 틀 (변수+메소드) 
    -메소드는 함수라고 생각하면 된다.
  -객체 : 구현할 대상이다. 클래스의 인스턴스라고 불리우며, 모든 인스턴스의 모임이다.
  -인스턴스 : 구현할 구체적인 실체이다. 변수들이 모여 인스턴스를 이룰 수 있으며, 여러과정도 인스턴스라고 불리운다.    
              이를 생성된 복제본이라고도 한다. (new 생성자같은 것)
  ```
  - 이를 단계로 나누는 것을 추상화 기법이라고한다.
    - 분류 : 객체 -> 클래스 
    - 인스턴스화 : 클래스 -> 인스턴스화 
  ``` 
  JAVA의 변수 기능들 
  String : String에서 저장되는 문자열은 바꿀 수 없다. 하지만 Stack에 쌓이며, 가비지 콜렉터가 호출되기 전까지는      
            메모리가 굉장히 비효율적으로 사용되므로 직섭생성이아닌 append 형식으로 아래의 기능을 활용하자. 
  StringBuffer : 동기식 문자열처리 -> 동기식 처리를 하기에 조금 더 안전하다.
  StringBulider : 비동기식 문자열처리
        - 비동기식 : 호출이 되면 비동기구분을 먼저 실행을 하고 끝나면 다시 순서대로 실행되는 것 
        - 동기식 : 코드가 작성된 순서대로 실행되는 것 
  
  Public : 접근제한이 없음
  Private : 자기 자신의 클래스만 접근이 가능 접근이 원하면 메소드를 만들어라 
  Protected : 파생 클래스나 같은 패키지에서만 사용 가능 
  default : 아무 선언을 안하는 것을 칭하며, 같은 패키지에서만 사용가능 
  ```
  ```
  Type        Bits      Range of Values
----------------------------------------------------------------------------------------
byte         8bits    -2^7 ~ 2^7-1 (-128 ~ 127)
short       16bits    -2^15 ~ 2^15-1 (-32768 ~ 32767)
int         32bits    -2^31 ~ 2^31-1 (-2147483648 ~ 2147483647)
long        64bits    -2^63 ~ 2^63-1 (-9223372036854775808 ~ 9223372036854775807)
float       32bits    0x0.000002P-126f ~ 0x1.fffffeP+127f
double      64bits    0x0.0000000000001P-1022 ~ 0x1.fffffffffffffP+1023  
char        16bits    \u0000 ~ \uffff (0 ~ 2^15-1) * 자바에서 unsgined로 동작하는 자료형
boolean      1bit     true, false
8Bits = 1Byte
  ```
  
  ##### Reflection 
  - 다른 객체지향 언어에서는 볼 수 없는 기능, 이미 로딩이 완료된 클래스에서 다른 클래스를 동적 로딩을 하여, 사용하는 것이다.
  - 구체적인 타입을 모르더라도, 그 클래스의 메소드, 타입, 변수들을 접근할 수 있도록 해준다.
  - Spring에서 어노테이션(@)의 기능과 같다. 힙 영역에 있는 클래스 정보를 가져올 수 있다.
  - 이를 사용할 때에 private 멤버도 접근이 될 수 있으니 사용할 때는 주의하면서 사용하자.
  - 이가 나온 이유는 동적언어인 JS,Python 과 다르게 정적언어인 C,C++,Java의 문제를 해결하기 위해서 이다.

  ##### equals vs == 
  ![image](https://img1.daumcdn.net/thumb/R800x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F1137EB394D6B4A4017)
  - eqauls는 주소값 자체를 비교한다. 즉 생성자로 변수 값은 같은 변수를 만들어도 주소가 다르기에 false가 나온다. 
  - ==은 내용 자체를 비교한다.
  
  ##### Static vs Non-static 
  - 정적변수와 동적 변수에 차이이다.
  - static을 선언하면 메서드 영역으로 변수가 들어가서 누적된 값을 호출할 수 있다. 
  
  ##### Call by Reference vs Call by Value 
  - Call by Value (값에 의한 호출)
    - 자바의 기본형이다. 참조형으로는 함수에 의한 호출이라고 하지만, 기본적으로 인자를 넘길때 값을 넘겨 복사가 된다.
    - 값을 부르기에 호출시에 메모리의 임시공간이 생성후 복사된다.
    - 불러진 곳에서 변수를 변경하면, 값이 복사 된 것이기에 변동되지 않는다.
  - Call by Reference (함수에 의한 호출)
    - 기본적인 포인터의 개념이다.
    - 값이 변동되면 함께 변동이 된다. 
  ##### Abstract Class vs Interface 
   - Abstartct Class
    - 한 개의 추상 메서드가 있으면 무조건 Absract를 선언해야하며, 모든 추상 메서드를 오버라이딩 가능해야 한다.
      - 반대로 메서드가 없으면 선언해도 되고 안해도 된다. 
    - 인스턴스 생성 목적이 아닌, 부모클래스 활용목적이다.
    - 단일 상속을 위해서 사용한다.  
    - 상속받은 클래스의 기능 확장.

   - Interface 
    - 기본적인 뼈대를 만들어준다 생각하면 된다. 
    - 의존성을 많이 줄여줄 수 있다. 
    - 다중 상속을 위해서 사용한다.
    - 상속받은 클래스의 기능 동일. (확장보다는 기본뼈대를 넣어줄때 사용)
    
#### FRAMEWORK
- NODE
  - ![img](https://blog.kakaocdn.net/dn/bcKQfy/btqF3GWwNSK/lGEBlvgtKoA51YK1clMue1/img.gif)
  - 단순 CPU작업만을 사용하는대에 유리하다. 싱글스레드에서는 노드가 더 빠른 속도를 보인다.
  - 자바스크립트 기반이기에 프론트엔드 개발자가 배우기에 러닝커브가 낮을 수 있다.
  - 자바스크립트의 언어적 특성(타입세이프)때문에 서비스가 커지면 런타임이 걸릴 수 있고 에러 찾기가 힘들다.
- SPRING
  - ![img](https://blog.kakaocdn.net/dn/bsDJqc/btqF4zic8Zz/h3wrLJ0Hc8kNKKwWnM2Ckk/img.gif)
  - JAVA 기반에 프레임워크. 
  - 설정이 복잡하지만, 스레드처리면에서는 노드보다 우수하다.
  - 스레드처리를 하기위해 메모리를 많이 사용하다보니 부담이 많이 갈 수 있다.
