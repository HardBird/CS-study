# frontend

[기본 CS지식은 위 링크에서 정리가 잘되어 있으니 한번 읽고서부터 아래를 읽어보도록하자](https://mangkyu.tistory.com/88) 

##### FRONTEND
  - Closer , Hoisting은 다른 웹사이트가 정리를 잘해주었으니, 검색해서 개념을 잡아주자 
  
#### HTML 
  - 이벤트의 발생은 하위 -> 상위로 발생(이벤트버블링)하고, 
  - 이벤트의 탐색은 상위 -> 하위로 (이벤트캡쳐링) 트리구조로 이루어져 있다. 이를 이벤트 위임이라고한다. 
  - 이 두가지가 상위 하위 이벤트핸들링하는 방법이다.
  - 기본적으로 뷰는 실행컨텍스트로 이루어지는데 전역컨텍스트가 한개 만들어지면 그 안에 함수컨텍스트들로 이루어진다.
  - XHTML과 HTML이 있는데 JSX처럼 확장된 언어이다. 조금 더 엄격한 규칙이 적용되어져 있다. 
  - 파일 초반에 HTML DOCTYPE 을 선언해서 markdown 언어에 대한 설정을 한다. 
  - Lazy Loading을 통하여 CSR의 이점을 챙겨온다. ( 초기에 렌더링을 하여서 메모리 효율적 관리 ) 
```
-HTML 동작원리
1. 사용자가 특정 웹사이트를 도메인을 입력한다.
2. 도메인이 입력되면 DNS서버에서 해당 도메인에 맞는 ip를 가져온다.
3. 결과 값으로 HTML 파일이 나오면 웹 브라우저는 해당 HTML을 파싱한다.
4. 파싱한후에 DOM 트리를 만들어 나간다. 
5. DOM트리가 완성되면 CSS를 파싱해주며, 사이트의 뷰를 띄워준다.
```
- 중간중간 JS를 만나면 제어권한을 넘기고 JS를 파싱하고 실행하는 과정이 있다.
- 보통의 대형 서비스는 서버가 하나터지면 대체서버를 바로 사용하는 무중단배포가 있다.
- 기본적으로 아래와 같은 구조로 이루어져 있다.

![image](https://media.vlpt.us/images/araaaaan/post/b99d2d54-fb43-4cc1-be09-2b9c3f6f6782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.35.26.png)
- 웹서버 : 주로 정적인 데이터 처리를 한다. 사용자에게 뿌려지는 뷰나 사용자에게 받는 정적인 데이터들을 저장 및 관리를 한다.
- 웹애플리케이션서버 : 주로 동적인 데이터 처리를 한다. DB에 관련된 내용에대해서 CRUD가 이루어지거나, SQL MAPPER나 ORM을 이용한다. 
- 이 두개를 따로 사용하는 이유는 서버의 과부하를 막기 위해서 사용되는 목적이다.

#### Webpack & Babel
  - Webpack
    - 자바스크립트는 모듈을 지원하지 않기 때문에, 모듈 설치 패키지라고 생각하면 된다. 
    - 패키지매니저로는 npm과 yarn이 있다. 버전을 맞춰주려 yarn을 주로 사용했지만 요즘에는 npm에도 package를 해주기 때문에 어떤걸 사용해도 된다. 
    - Dependencies 와 devDependenices 가 있는데 이는 환경에 필요한 패키지 / 테스트와개발에 필요한 패키지 두개의 차이가 있다. 
  - Babel 
    - 버전을 맞춰주는 기술이다. ES6에서 나온 문법이며, ES6를 기준으로 코딩을해도 ES5로 변환을 해준다. 


#### AMP
- 웹페이지의 빠른 렌더링을 위한 캐시 기술스택이다. 
- 모든 외부 JS파일들은 비동기로 처리한다. 

#### CSS vs SCSS,Sass 
  - CSS에서의 접근연산자 > , :not 등을 조금 더 보기 쉽게 작성할 수 있는 CSS문법이라고 생각하면된다.
  - SCSS는 중괄호 {} , Sass는 세미콜론 ; 으로 문맥을 구분한다.

#### inline vs block 
  - 둘다 CSS 문법이다. <span/>이 예시로 둘 수 있다.  
  - inline은 margin이나 padding에 대한 값의 변동을 적용하는대에 제한이 있다.
  - Block은 자유롭게 설정할 수 있다.
  - Block에 inline을 적용하고 싶으면 inline-block 선언을 해주면 된다. 

#### import vs require 
  - require는 ES6전 라이브러리를 호출할 때 사용하는 문법이였다. 
  - 두 개의 의미는 같이 사용되지만 만약 NodeJS에서 Babel을 사용하지 않을 경우에는 require를 사용해주어야 한다. 

#### JAVASCRIPT 
  - 자바스크립트는 유저의 편의성을 위해 짧은 시간만에 개발된 동적 언어이다.
  - 짧은 시간에 나왔기에, ES6 표준안이 나오기전까지는 여러 이슈가 많았다. (var 변수 사용을 통한이슈)
  - 배열 구조는 실제 자료구조 배열이 아닌 HashMap으로 구현되어있다. 
    - 그 이유는 정적인언어 C,C++,JAVA 등과 다르기에 동적으로 메모리할당을 더 효율적으로 하기 위해서이다. 
  - 그렇기에 다른 언어와 다르게 class기반이 아닌 prototype 기반으로 virtual DOM에 렌더후 사용자 DOM에 렌더해준다. 
  - 이는 단일스레드 언어이며, 앱 워커를 사용하여 멀티스레드 구현도 가능하다. 
  ```
  - 단일스레드에서의 이벤트 루프 & 버블링 (동작원리)
    - 기본적으로 단일스레드에서는 스택을 통해서 한줄씩 작업을 관리하며 동기적&비동기적으로 순서가 정해진다.
      (기본적으로는 스택에 있는 명령을 처리하는 동기적구조이다.)
    - 즉 setTimeout()을 걸어도, 그 부분을 기다리고 다시 시작이 아닌, 다 실행후에 setTimeout()을 실행한다.
    - 스택을 너무 무분별하게 사용하거나 (시간복잡도가 엄청많거나) 이벤트를 너무 많이 사용하면 (큐 과부하) 사이트가 마비된다.
    
    1. 이 원리는 각 Task를 스택 안에서 명령을 실행하고 힙 안에서 변수를 선언한다. 
    2. 단 스택안에서 처리가 오래걸리는 비동기/시간/이벤트리스너 관련된 명령어는 큐(일반)에 따로 보내둔다.
    3. 스택에 명령이 끝나면(empty) 큐(대기실)에 다시 보내서, 스택으로 하나씩 올려보낸다.
                                                                                                        (아래 이미지 참조)
  ```
  ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdZ8YBt%2FbtqwhxzE1py%2FRQNPdMhyWbLZ3zDAptsVhK%2Fimg.png)
 
  ![image](https://blog.kakaocdn.net/dn/c7OXFt/btqwhUVuXGv/rYhxWO3UOuPePPe2nVL3P1/img.gif)
  - 원시타입의 종류로는 null,undefined,number,string,boolean,object가 있다. 
  - 선언되는 위치에 따라서는 클로져(clouser)가, 호출하는 방법에 따라서는 this를 기억하자. 
  ```
  This 정의
    - 자신이 속한 객체에서 인스턴스를 가르킬때 사용한다.
    - bind,call,apply를 사용하여 핸들링 할 수 있다.
      bind : 새로운 것을 가르키는데 사용.
      call : this에 바인딩 된 것을 호출하는데 사용.
      apply : this에 바인딩을 시켜주는데 사용.
    - 전역에서는 window를 가르키기 때문에 애로우함수내에서 this를 선언해주거나 new를 통해서 생성자에 this를 바인드 해주자. 
    - strict모드에서는 this가 window가 아닌 strict를 가르킨다.
              cf) strict mode
              ES5에 나온 제한된 모드를 선언하는 것이고, 데이터를 read only만 가능하다.
              가볍게 넘기던 warning이나 문법적 오류를 전부다 검사를 해주는 모드이다. 
  ```
    - 기본적인 함수들은 대부분 ES6에서 생성이 되었다. (import,arrow function,spread,const&let,promise 등)
#### JAVASCRIPT Throw&Try ~ catch ~ finally 
- try~catch~finally 에서 비동기처리를 한번 더 시행을 하면, 오류를 잡아 낼 수 없다. 그렇기에 한번 더 try catch문을 안에 작성해주어야한다.   
  (예시: try문에 setTimeout()이 있다면 해당 부분은 오류를 잡지못해서 setTimeout()안에 한번 더 try catch문을 선언해주어야함) 
- Promise객체에 대해서는 async ~ await을 사용해야만 에러 헨들링 처리를 할 수 있다. 
- Throw: 예외처리를 위한 명령어이다. 아래에 예시를 기재했다.
- try: 무언가를 시도하는 구문 try가 정상적으로 되면 catch문에 접근하지 않으며, 에러가 생길시에는 try를 멈추고 catch로 넘어간다.
- catch(e): 특정에러가 발생했을때 접근하는 구문 에러에 대한 정보는 e parameter에 들어가 있다. 
- finally: try와 catch이후에 실행되는 구문, 보통 몇번의 로직이 돌았는지, true/false 값을 상관안하고 핸들링 처리할 때 사용한다.
```Javascript
function factorial(x) 
{
// 만약 전달인자가 유효하지 않으면 예외를 발생시킨다!!! 
if (x < 0) {
throw new Error('x는 음수가 아니어야 합니다.') } // 유효하다면 값을 계산하여 정상적으로 반환환다. 
for (var f = 1; x > 1; f *= x, x--) /* 비어 있음 */
return f;
}

try { 
/** 
* 정상이라면 이 코드는 아무런 문제없이 블록의 시작부터 끝까지 실행된다.
* 하지만 경우에 따라 예외가 발생할 수 있다.
* 예외는 throw 문에 의해 직접적으로 발생할 수도 있고, 
* 또는 예외를 발생시키는 메서드의 호출에 의해 발생할 수도 있다.
*/
}
catch (e) {
/** 
* 이 블록 내부의 문장들은 오직 try 블록에서 예외가 발생할 경우에만 실행된다.
* 이 문장들에선 지역 변수 e를 사용하여 Error 객체 또는 앞에서 던진 다른 값을 참조할 수 있다. 
* 이 블록에서는 어떻게든 그 예외를 처리할 수도 있고, 
* 그냥 아무것도 하지 않고 예외를 무시할 수도 있고,
* 아니면 throw 를 사용해서 예외를 다시 발생시킬 수도 있다. 
*/ 
}
finally {
/** 
* 이 블록에는 try 블록에서 일어난 일에 관계없이 무조건 실행될 코드가 위치한다. 
* 이 코드는 try 블록이 어떻게든 종료되면 실행된다.
* try 블록이 종료되는 상황은 다음과 같다.
* 1) 정상적으로 블록의 끝에 도달했을 때
* 2) break, continue 또는 return 문에 의해서 
* 3) 예외가 발생했지만 catch 절에서 처리했을 때
* 4) 예외가 발생했고 그것이 잡히지 않은 채 퍼져나갈 때 
*/
}
```
#### JAVASCRIPT Eslint 
 - 소스코드를 스캔하여서 잠재적 오류를 찾아내는 디버깅 도구 

#### JAVASCRIPT GARBAGE COLLECTOR
- 참조된 값을 사용하고 더이상 참조되는 값에 대해서 사용하지 않거나, 메모리 할당을 시행하고 더 이상 사용하지 않을때    
      자체적으로 메모리 할당을 해제하여 메모리를 관리해주는 것 
- 사용자가 강제적으로 실행 종료를 할 수 없다. 

#### JAVASCRIPT Promise 
- 초기 콜백함수에 대한 대처 기술로 나왔다. (계속해서 콜백을 할 경우 로직이 복잡해지고 보수가 어려워지기 때문에)
- 하지만 Promise만 사용할 경우에는 then이 콜백처럼 엄청 사용해야 하기때문에 복잡한 부분이 있었다.
- 비동기 통신에 시작, 발목을 잡을수도 도움을 줄수도 있는 객체 형태이다.
- 말그대로 약속을 해주는 개체이기에 이 일을 처리해줄게 ~ 라는 의미를 가진다.
- async ~ await() 을 같이 사용하지 않으면 promise가 종종 비어있는 객체로 받아져서 JSON.parse()를해도 원하는 값을 받지 못할 수 있다.
- async ~ await() 이 생기면서 fetch() ~ then()의 복잡한 구문을 줄여 줄 수 있게 되었다. 
- 위에서 언급한것처럼 try~catch문에서 promise만 사용할 경우에 promise도 객체 취급을 받기 때문에 에러 핸들링 처리가 번거롭다. 
```
-비동기 통신에 기본 AJAX
  - 서버와 클라이언트간에 통신을 하는 기술을 AJAX라고 한다. 
  - 기본적으로 XML, JSON 형태를 선택해서 받을 수 있으며 비동기통신이다. 
  

```

#### Restful API 
- 클라이언트와 서버사이에 URI링크에 필요한 정보와 요청할 정보를 담아서 데이터를 주고받는 기술 
- 과거의 SOAP의 복잡함을 해결해주는 기술이다. 
- 기능만이 아닌 가독성과 효율성을 위해서 나온것이다.
- 주소만으로 무엇을하는 것인지 알 수 있다. (URI = 행위 , method = CRUD를 포함하기 때문에)
#### JQUERY 
- 조금 더 효율적으로 JS를 사용할 수 있는 JS 라이브러리이다. 
- detach() , remove() : 삭제하고 잔여물 남기기 / 삭제하고 잔여물도 없애기 
- .min.js로 경량화작업이 가능하다. 
- onload() , document.ready() : 객체가 모두 표시된후 호출 / DOM이 생성시에 바로 호출 

#### REACT 
- 클래스형과 함수형 구조로 만들수 있다. 
```
클래스형 - 
1. 컴포넌트를 상속 받아사용할때 this.pros; 구문을 사용하여서 변수에 접근할 수 있다. 
2. 애로우 함수와 this를 합쳐서 사용해야 한다. 
3. useState 없이 this로 선언을해도 값에 대한 렌더가 가능하다. (render함수가 있기 때문에)

함수형 - 
1. 컴포넌트를 상속 받아사용할때 바로 접근하여 사용할 수 있다. 
2. const + function() 형태로 합쳐서 사용해야 한다. 
3. useState를 사용해서 값에 변동을 체크해야 값에 대한 렌더가 가능하다. (render함수가 없기 때문에)

```

