# frontend

[기본 CS지식은 위 링크에서 정리가 잘되어 있으니 한번 읽고서부터 아래를 읽어보도록하자](https://mangkyu.tistory.com/88) 

##### FRONTEND
![image](https://user-images.githubusercontent.com/67629949/137179421-1862c75e-03ee-4dd5-afdc-8c1dd40410e4.png)



#### Const Var Let 
```
- var
  함수레벨 스코프에서 사용되는 변수 선언이다. 
  재사용성과 재선언이 가능하다. 
  이 친구때문에 JS의 시작이 쉬울지 모르지만 이 친구때문에 Hoisting이라는 재앙이 시작됐다.
  현재에는 잘 사용하지 않으며 타입의 중요성이 생기면 typescript가 나오기 시작했다.

- let 
  블록레벨 스코프에서 사용되는 변수 선언이다.
  재사용성은 가능하나 재선언을 불가능하다.

- const 
  블록레벨 스코프에서 사용되는 변수 선언이다.
  재사용선건과 재선언이 둘 다 불가능하다. 
```

  
#### HTML 
  - 이벤트의 발생은 하위 -> 상위로 발생(이벤트버블링)하고, 
  - 이벤트의 탐색은 상위 -> 하위로 (이벤트캡쳐링) 트리구조로 이루어져 있다. 이를 이벤트 위임이라고한다. 
  - 이 두가지가 상위 하위 이벤트핸들링하는 방법이다.
  - 기본적으로 뷰는 실행컨텍스트로 이루어지는데 전역컨텍스트가 한개 만들어지면 그 안에 함수컨텍스트들로 이루어진다.
  - XHTML과 HTML이 있는데 JSX처럼 확장된 언어이다. 조금 더 엄격한 규칙이 적용되어져 있다. 
  - 파일 초반에 HTML DOCTYPE 을 선언해서 markdown 언어에 대한 설정을 한다. 
  - Lazy Loading을 통하여 CSR의 이점을 챙겨온다. ( 초기에 렌더링을 하여서 메모리 효율적 관리 ) 
```
-HTML 동작원리
1. 사용자가 특정 웹사이트를 도메인을 입력한다.
2. 도메인이 입력되면 DNS서버에서 해당 도메인에 맞는 ip를 가져온다.
3. 결과 값으로 HTML 파일이 나오면 웹 브라우저는 해당 HTML을 파싱한다.
4. 파싱한후에 DOM 트리를 만들어 나간다. 
5. DOM트리가 완성되면 CSS를 파싱해주며, 사이트의 뷰를 띄워준다.
```
```
-DNS SERVER 
    웹사이트의 데이터가 저장되어 있는 호스팅 서버는 인터넷 회선이 연결된 컴퓨터/장치인지라 IP 주소가 할당되어 있고 이 주소가 실제 웹사이트 주소라 할 수 있음. DNS 서버는 이런 IP 주소     를 특정 도메인 주소와 같다는 기록을 저장해두고, 인터넷 사용자들이 도메인 주소를 검색했을 때 IP 주소로 연결되도록 해줌. 이는 여러 통신사가 DNS 서버가 될 수 있으며,
    AWS같은 서버 호스팅 서비스에서도 DNS 서버가 될 수 있다.
```
- 중간중간 JS를 만나면 제어권한을 넘기고 JS를 파싱하고 실행하는 과정이 있다.
- 보통의 대형 서비스는 서버가 하나터지면 대체서버를 바로 사용하는 무중단배포가 있다.
- 기본적으로 아래와 같은 구조로 이루어져 있다.

![image](https://media.vlpt.us/images/araaaaan/post/b99d2d54-fb43-4cc1-be09-2b9c3f6f6782/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-08-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.35.26.png)
- 웹서버 : 주로 정적인 데이터 처리를 한다. 사용자에게 뿌려지는 뷰나 사용자에게 받는 정적인 데이터들을 저장 및 관리를 한다.
- 웹애플리케이션서버 : 주로 동적인 데이터 처리를 한다. DB에 관련된 내용에대해서 CRUD가 이루어지거나, SQL MAPPER나 ORM을 이용한다. 
- 이 두개를 따로 사용하는 이유는 서버의 과부하를 막기 위해서 사용되는 목적이다.

#### Webpack & Babel
  - Webpack
    - 자바스크립트는 모듈을 지원하지 않기 때문에, 모듈 설치 패키지라고 생각하면 된다. 
    - 패키지매니저로는 npm과 yarn이 있다. 버전을 맞춰주려 yarn을 주로 사용했지만 요즘에는 npm에도 package를 해주기 때문에 어떤걸 사용해도 된다. 
    - Dependencies 와 devDependenices 가 있는데 이는 환경에 필요한 패키지 / 테스트와개발에 필요한 패키지 두개의 차이가 있다. 
  - Babel 
    - 버전을 맞춰주는 기술이다. ES6에서 나온 문법이며, ES6를 기준으로 코딩을해도 ES5로 변환을 해준다. 

#### Ajax 
- 클라이언트에서 직접적인 접근없이 http 통신 규약을 사용하여 서버에서 데이터를 받아오는 기술 
- 받아오는 데이터는 JSON/XML 두가지로 받아올 수 있다. 
  - JSON: XML보다 사용자가 조금 더 직관적으로 볼 수 있는 데이터 구조, 데이터의 형태는 정해져있으며 모듈설치없이 문자열로 받아올 수 있다.
  - XML: 계층적인 구조로 return을 받는 데이터 구조, 데이터 형태가 자유로우며 xml 파싱 모듈이 있어야만 데이터를 받아올 수 있다. 
- REST API 구조를 이루고 있다.
  - RESTAPI : SQL조건문등을 사용하지 않고 URI에 필요한 명령어를 입력하고 method를 요청하여 원하는 데이터를 받거나 정정할 수 있는 것.
- 기본적인 통신 스택은로는 ajax, axios, fetch가있다. 
```
-ajax: 기본적으로 jQuery 기반으로하는 데이터 송/수신구조이다. promise 객체가 아닌 콜백구조이다.
-axios: 모듈을 설치해야하는 데이터 송/수신 구조이다. nodeJS기반으로 작업을 할 시에 일관성에 효과를 줄 수 있다.
-fetch: JS에 기본적으로 내장되어 있는 데이터 송/수신 구조이다. promise 객체이다. 

    - promise 
    대기(pending) : 아직 실행되지 않은 초기 상태
    이행(fulfilled) : 작업이 성공적으로 완료됨.
    거부(rejected) : 작업이 실패함. 이를 시행할시에는 try ~ catch 가아닌 promise ~ then ~ catch 구문을 사용한다.
    
    작업이 성공적으로 이행이 되었거나, 실패 했을 때, 어떠한 작업을 해야 하는데 이 작업은 then 메소드에 의해 실행된다. 
    이는 callback함수를 실행한 것과 같은 효과를 낸다. then 메소드는 promise객체에 붙여서 사용한다.
    promise가 너무 복잡하게 체이닝(chaning)되면 async ~ await()을 사용하여 코드를 간결하게 해줄 수 있다.
    이를 사용하면, promise ~ then 구조로 작성을하지 않아도 된다. (대기 -> 이행 & 거부를 다 기다려줌)
    
    promise.all(함수1,함수2) 을 사용하면 비동기적 병렬처리가 가능하다
    promise.race(함수1,함수2) 을 사용하면 비동기적 처리중 가장 먼저온것을 출력하고 종료시킬수 있다.

```
 
#### AMP
- 웹페이지의 빠른 렌더링을 위한 캐시 기술스택이다. 
- 모든 외부 JS파일들은 비동기로 처리한다. 

#### CSS vs SCSS,Sass 
  - CSS에서의 접근연산자 > , :not 등을 조금 더 보기 쉽게 작성할 수 있는 CSS문법이라고 생각하면된다.
  - SCSS는 중괄호 {} , Sass는 세미콜론 ; 으로 문맥을 구분한다.

#### inline vs block 
  - 둘다 CSS 문법이다. <span/>이 예시로 둘 수 있다.  
  - inline은 margin이나 padding에 대한 값의 변동을 적용하는대에 제한이 있다.
  - Block은 자유롭게 설정할 수 있다.
  - Block에 inline을 적용하고 싶으면 inline-block 선언을 해주면 된다. 

#### import vs require 
  - require는 ES6전 라이브러리를 호출할 때 사용하는 문법이였다. 
  - 두 개의 의미는 같이 사용되지만 만약 NodeJS에서 Babel을 사용하지 않을 경우에는 require를 사용해주어야 한다. 

#### JAVASCRIPT 
  - 자바스크립트는 유저의 편의성을 위해 짧은 시간만에 개발된 동적 언어이다.
  - 짧은 시간에 나왔기에, ES6 표준안이 나오기전까지는 여러 이슈가 많았다. (var 변수 사용을 통한이슈)
  - 배열 구조는 실제 자료구조 배열이 아닌 HashMap으로 구현되어있다. 
    - 그 이유는 정적인언어 C,C++,JAVA 등과 다르기에 동적으로 메모리할당을 더 효율적으로 하기 위해서이다. 
  - 그렇기에 다른 언어와 다르게 class기반이 아닌 prototype 기반으로 virtual DOM에 렌더후 사용자 DOM에 렌더해준다. 
  - 이는 단일스레드 언어이며, 앱 워커를 사용하여 멀티스레드 구현도 가능하다. 
  ```
  - 단일스레드에서의 이벤트 루프 & 버블링 (동작원리)
    - 기본적으로 단일스레드에서는 스택을 통해서 한줄씩 작업을 관리하며 동기적&비동기적으로 순서가 정해진다.
      (기본적으로는 스택에 있는 명령을 처리하는 동기적구조이다.)
    - 즉 setTimeout()을 걸어도, 그 부분을 기다리고 다시 시작이 아닌, 다 실행후에 setTimeout()을 실행한다.
    - 스택을 너무 무분별하게 사용하거나 (시간복잡도가 엄청많거나) 이벤트를 너무 많이 사용하면 (큐 과부하) 사이트가 마비된다.
    
    1. 이 원리는 각 Task를 스택 안에서 명령을 실행하고 힙 안에서 변수를 선언한다. 
    2. 단 스택안에서 처리가 오래걸리는 비동기/시간/이벤트리스너 관련된 명령어는 큐(일반)에 따로 보내둔다.
    3. 스택에 명령이 끝나면(empty) 큐(대기실)에 다시 보내서, 스택으로 하나씩 올려보낸다.
                                                                                                        (아래 이미지 참조)
  ```
  ![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FdZ8YBt%2FbtqwhxzE1py%2FRQNPdMhyWbLZ3zDAptsVhK%2Fimg.png)
 
  ![image](https://blog.kakaocdn.net/dn/c7OXFt/btqwhUVuXGv/rYhxWO3UOuPePPe2nVL3P1/img.gif)
  - 원시타입의 종류로는 null,undefined,number,string,boolean,object가 있다. 
  - 선언되는 위치에 따라서는 클로져(clouser)가, 호출하는 방법에 따라서는 this를 기억하자. 
  ```
  This 정의
    - 자신이 속한 객체에서 인스턴스를 가르킬때 사용한다.
    - bind,call,apply를 사용하여 핸들링 할 수 있다.
      bind : 새로운 것을 가르키는데 사용.
      call : this에 바인딩 된 것을 호출하는데 사용.
      apply : this에 바인딩을 시켜주는데 사용.
    - 전역에서는 window를 가르키기 때문에 애로우함수내에서 this를 선언해주거나 new를 통해서 생성자에 this를 바인드 해주자. 
    - strict모드에서는 this가 window가 아닌 strict를 가르킨다.
              cf) strict mode
              ES5에 나온 제한된 모드를 선언하는 것이고, 데이터를 read only만 가능하다.
              가볍게 넘기던 warning이나 문법적 오류를 전부다 검사를 해주는 모드이다. 
  ```
    - 기본적인 함수들은 대부분 ES6에서 생성이 되었다. (import,arrow function,spread,const&let,promise 등)
  ```
  Super 정의 
   - 상위 클래스의 생성자를 호출 할 때는 super()로 선언한다.
   - 부모 클래스의 메소드를 사용하는것을 supermethod 라고한다.
   - 즉 괄호의 유무는 괄호가있다면 생성자 없다면 객체를 의미한다.
   - super 자체는 부모 클래스를 의미한다. (부모님은 슈퍼맨이다..)
  
  ```
    
   
#### JAVASCRIPT CLOSURE 
  - 원하는 시점에서 내부 클로저를 실행할 수 있다. 
  - 즉 부모클래스나 메소드에서 상속된 자식 클래스나 메소드를 접근할 때에 부모 클래스로 변수가 선언되어도 내부로 접근이 가능하다.
  - 이를 스코프체인이라고도 한다. 

#### JAVASCRIPT HOISTING
  - 함수안에 있는 선언들을 모두 끌어올려서 유효 범위의 최상단으로 선언하게 해주는것이다.
  - 메모리적으로 변화는 없으며 var 변수 선언과 함수선언문에서만 호이스팅이 발생한다.
  - 변수의 선언과 대입을 두가지로 나뉘어서 선언을 최상단 스코프에서 실행해준다.
  - 함수내에서 변수형태를 선언하지않고 실행하면 자동으로 전역변수로 선언이된다. 
      예시:
      ```Javascript
      console.log(name);//undefined
      a();
      function a(){
      name = 'bang';
      }
      console.log(name);//bang
      ```
      
      ```Javascript
      console.log(name);//bang
      a();
      function a(){
      var name = 'bang';
      }
      console.log(name);//bang
      ```
      


#### JAVASCRIPT Throw&Try ~ catch ~ finally 
- try~catch~finally 에서 비동기처리를 한번 더 시행을 하면, 오류를 잡아 낼 수 없다. 그렇기에 한번 더 try catch문을 안에 작성해주어야한다.   
  (예시: try문에 setTimeout()이 있다면 해당 부분은 오류를 잡지못해서 setTimeout()안에 한번 더 try catch문을 선언해주어야함) 
- Promise객체에 대해서는 async ~ await을 사용해야만 에러 헨들링 처리를 할 수 있다. 
- Throw: 예외처리를 위한 명령어이다. 아래에 예시를 기재했다.
- try: 무언가를 시도하는 구문 try가 정상적으로 되면 catch문에 접근하지 않으며, 에러가 생길시에는 try를 멈추고 catch로 넘어간다.
- catch(e): 특정에러가 발생했을때 접근하는 구문 에러에 대한 정보는 e parameter에 들어가 있다. 
- finally: try와 catch이후에 실행되는 구문, 보통 몇번의 로직이 돌았는지, true/false 값을 상관안하고 핸들링 처리할 때 사용한다.
```Javascript
function factorial(x) 
{
// 만약 전달인자가 유효하지 않으면 예외를 발생시킨다!!! 
if (x < 0) {
throw new Error('x는 음수가 아니어야 합니다.') } // 유효하다면 값을 계산하여 정상적으로 반환환다. 
for (var f = 1; x > 1; f *= x, x--) /* 비어 있음 */
return f;
}

try { 
/** 
* 정상이라면 이 코드는 아무런 문제없이 블록의 시작부터 끝까지 실행된다.
* 하지만 경우에 따라 예외가 발생할 수 있다.
* 예외는 throw 문에 의해 직접적으로 발생할 수도 있고, 
* 또는 예외를 발생시키는 메서드의 호출에 의해 발생할 수도 있다.
*/
}
catch (e) {
/** 
* 이 블록 내부의 문장들은 오직 try 블록에서 예외가 발생할 경우에만 실행된다.
* 이 문장들에선 지역 변수 e를 사용하여 Error 객체 또는 앞에서 던진 다른 값을 참조할 수 있다. 
* 이 블록에서는 어떻게든 그 예외를 처리할 수도 있고, 
* 그냥 아무것도 하지 않고 예외를 무시할 수도 있고,
* 아니면 throw 를 사용해서 예외를 다시 발생시킬 수도 있다. 
*/ 
}
finally {
/** 
* 이 블록에는 try 블록에서 일어난 일에 관계없이 무조건 실행될 코드가 위치한다. 
* 이 코드는 try 블록이 어떻게든 종료되면 실행된다.
* try 블록이 종료되는 상황은 다음과 같다.
* 1) 정상적으로 블록의 끝에 도달했을 때
* 2) break, continue 또는 return 문에 의해서 
* 3) 예외가 발생했지만 catch 절에서 처리했을 때
* 4) 예외가 발생했고 그것이 잡히지 않은 채 퍼져나갈 때 
*/

throws { 
/**
* throw는 그 스코프에서 에러를 선언할 수 있지만 
* throws는 상위 메소드로 에러를 전달한다.
* 이는 JAVA 문법이다.
*/
}
```
#### JAVASCRIPT Eslint 
 - 소스코드를 스캔하여서 잠재적 오류를 찾아내는 디버깅 도구 

#### JAVASCRIPT GARBAGE COLLECTOR
- 참조된 값을 사용하고 더이상 참조되는 값에 대해서 사용하지 않거나, 메모리 할당을 시행하고 더 이상 사용하지 않을때    
      자체적으로 메모리 할당을 해제하여 메모리를 관리해주는 것 
- 사용자가 강제적으로 실행 종료를 할 수 없다. 

#### JAVASCRIPT Promise 
- 초기 콜백함수에 대한 대처 기술로 나왔다. (계속해서 콜백을 할 경우 로직이 복잡해지고 보수가 어려워지기 때문에)
- 하지만 Promise만 사용할 경우에는 then이 콜백처럼 엄청 사용해야 하기때문에 복잡한 부분이 있었다.
- 비동기 통신에 시작, 발목을 잡을수도 도움을 줄수도 있는 객체 형태이다.
- 말그대로 약속을 해주는 개체이기에 이 일을 처리해줄게 ~ 라는 의미를 가진다.
- async ~ await() 을 같이 사용하지 않으면 promise가 종종 비어있는 객체로 받아져서 JSON.parse()를해도 원하는 값을 받지 못할 수 있다.
- async ~ await() 이 생기면서 fetch() ~ then()의 복잡한 구문을 줄여 줄 수 있게 되었다. 
- 위에서 언급한것처럼 try~catch문에서 promise만 사용할 경우에 promise도 객체 취급을 받기 때문에 에러 핸들링 처리가 번거롭다. 

#### Restful API 
- 클라이언트와 서버사이에 URI링크에 필요한 정보와 요청할 정보를 담아서 데이터를 주고받는 기술 
- 과거의 SOAP의 복잡함을 해결해주는 기술이다. 
- 기능만이 아닌 가독성과 효율성을 위해서 나온것이다.
- 주소만으로 무엇을하는 것인지 알 수 있다. (URI = 행위 , method = CRUD를 포함하기 때문에)
#### JQUERY 
- 조금 더 효율적으로 JS를 사용할 수 있는 JS 라이브러리이다. 
- detach() , remove() : 삭제하고 잔여물 남기기 / 삭제하고 잔여물도 없애기 
- .min.js로 경량화작업이 가능하다. 
- onload() , document.ready() : 객체가 모두 표시된후 호출 / DOM이 생성시에 바로 호출 

#### REACT 
- 클래스형과 함수형 구조로 만들수 있다. 
```
클래스형 - 
1. 컴포넌트를 상속 받아사용할때 this.pros; 구문을 사용하여서 변수에 접근할 수 있다. 
2. 애로우 함수와 this를 합쳐서 사용해야 한다. 
3. useState 없이 this로 선언을해도 값에 대한 렌더가 가능하다. (render함수가 있기 때문에)

함수형 - 
1. 컴포넌트를 상속 받아사용할때 바로 접근하여 사용할 수 있다. 
2. const + function() 형태로 합쳐서 사용해야 한다. 
3. useState를 사용해서 값에 변동을 체크해야 값에 대한 렌더가 가능하다. (render함수가 없기 때문에)

```
#### MVC vs FLUX 
```
- MVC
  초기에 가장 많이사용하는 디자인 패턴이였다. 그림과 같이 Model(데이터를 관리하는곳) / View(데이터를 보여주는곳) / Controller(Model<>View를 관리해주는곳) 으로 나뉘어져있다.
    -Model : Conntroller와 View에 의존하면 안된다. 즉 데이터만을 호출하고, 넣어주는 것 (깔끔정제그자체)
    -View : Model에만 의존해야한다. 즉 데이터를 받아서 출력하는 부분이며, Model에서 데이터를 받을때 사용자마다 다르게 보여주어야 하는 데이터에 대해서만 받아야한다.
    -Controller : Model과 View에 코드가 있을 수 있다. 단 View가 데이터를 받을때는 무조건 controller를 거쳐야한다. 
    
  하지만 Model과 View의 양방향 통신이 복잡하게 이루어지면 해당 부분을 디버깅하기에는 굉장한 시간을 소요하기도 하였고 서비스가 무거워지는 단점을 가지고 있었다. 
  다른 패턴보다는 특정 부분에서 데이터를 출력하고, 수정하는것에 체계화가 되있어서 효율적이였지만 서비스가 커질수록 단점이 보이기 시작하였다.
  이 부분에 대해서 해결하고자 나온것이 Flux 패턴이다. 물론 MVC를 보안한 MVP MVVM 등 여러 모델도 존재한다.
```

```
- FLUX 
   MVC에서 Model과 View가 너무 복잡하게 얽혀있어서 디버깅을 하기 어려워서 그 문제를 해결하고자 나온 패턴이다. 이는 아래과 같은 순서를 지킨다. 
   1. action 단계에서 특정 이벤트나 함수등을 실행을 시키게 되면 dispatch에 전송을 해준다. 
   2. dispatch 에서는 action에서 받은 이벤트나 함수를 동기적으로 처리하여 값을 갱신하거나 이벤트를 실행한다.
   3. 실행하여 변동된 뷰나 결과값은 dispatch에서 store로 전송하게된다. 
   4. store는 해당 부분을 갱신을 시켜주고 변경된 이벤트나 뷰에 대해서 다시 View에 제공을한다. 
   5. View 변동된 부분을 받아서 다시 렌더링 시켜주고 특정이벤트나 함수를 실행시키면 store로 보내는것이 아닌 다시 action을 호추하여 2-4 단계를 거친다.
   
   이는 추후에 페이스북에서 알림문제같은 원인을 해결 할 수 있었으며, 양방향통신보다 단방향통신을 하는 디자인 구조가 디버깅하는대에 더 효율적이라는 것을 알게 되었고 
   추후에 Redux나 Recoil redux-saga나 Context-API같은 더 효율적인 상태관리 라이브러리를 탄생시켰다. 
```



#### Redux 
  - 여러번 props를 사용하지 않고 전역에서 redux-state를 선언해서 어디서든 사용 할 수 있게 해주는 문법이다.
  - 그리고 상태관리에 용이한 문법이다. 여기서 상태관리는 특정변수에 대한 가감승제같은 기능을 의미한다. redux가 없다면 디버깅하는대에 각각의 컨포넌트에서 기능이 있기때문에 시간이 굉장히 소요된다 하지만 redux가 있으면 각각의 컨포넌트가 redux내에 있는 기능을 호출하기 때문에 오류가 나면 redux안에서만 확인을 하면 오류를 고칠 수 있다. 
  - 이를 Reducer라고 불리운다. 하위컴포넌트에선 dispatch를 이용해서 reducer를 호출하여서 사용할 수 있다.

#### Context API 
  - Redux와 같게 상태관리도구로 정의할 수 있다.
  - Redux와의 차이점은 Redux가 조금 더 많은 기능을 가지고 있다. 그렇기에 대형 프로젝트에 많은 기능을 사용한다면 context API보다 Redux를 사용하는게 조금 더 효율적이다.

#### React Hooks 
  - 함수형구조에서 클래스형구조에 장점을 사용하기 위해서 나온 기술이다.
  - useState, useEffect 등을 사용하여서 상태관리를해주어 라이프싸이클 메소드를 사용한다. 
  - 라이프싸이클 메소드란 리액트에 돔트리라이프 싸이클 구조를 의미한다. 
  - this로 상태를 관리하는 것보다 코드의 경량화가 가능하며 재사용성을 높여준다. 
  - Hooks가 나와도 컴포넌트구조와 함께 같이 사용한다. 


![image](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FeceuwJ%2FbtqF7ED8WpX%2FQTATE8lUtpkC09UkB85tG0%2Fimg.jpg)
```
-DomTree LifeCycle 
- 큰 구조로는 componentDidMount(초기화) -> componentDidUpdate(업데이트) -> componentWillunMount(소멸) 구조로 이루어진다.
- componentDidMount : Hook 개념이나 초기 렌더가 이루어지는 곳 
- componentDidUpdate : 성능최적화를 하는 구문이며, 값에 대한 업데이트를 해주는 곳 (Hooks에 의한 상태변환)
- componentWillunMount : 소멸단계, 자원의 해체가 이루어지는 곳이다. 

초기화 단계에서는 useMemo()  
업데이트 단계에서는 useState()
모든 단계에서는 useEffect()가 우선 순위를 가진다. 
```


#### React vs Vue 
  - 앵귤러는 typescript 기반이기에 처음부터 러닝커브가 높아서 논외로 하고 이야기하고자 한다
  - React는 Vue에 비해서 구조가 조금 더 재사용성이 뚜렷하다.
  - 하지만 Vue에서는 HTML,CSS,JS 파일을 나누어서 작업할 수 있으며 라이브러리와 템플릿 지원이 조금더 효율적이다.
  - 자료량은 React가 더 많다. 
  - 현재에는 React나 Vue나 참고자료나 라이브러리가 둘다 많기에 어떤걸 사용해도 괜찮다. 둘다 virtual DOM을 사용한다.
  - 코드의 재사용성은 React가 우수하다. Hooks의 개념으로 값을 업데이트하면 덮어씌울수 있지만 Vue에서는 계속해서 객체를 만들어주어야 한다.
  
  
#### GET vs POST 
  ```
  -GET 
  URL끝에 파라미터가 추가되어 전송되는 데이터 전송 형식 이를 쿼리스트링이라고한다. 
  이는 캐시가 가능하여 리소스 다운로드속도를 아끼고, 복사본을 바로 사용하여서 지정할 수 있다.
  이는 브라우저에 히스토리에 남는다.
  이는 데이터를 요청할때만 주로 사용한다.
  이는 따로 BODY가 없고 결과 값은 항상 동일하다.
  히스토리가 남기때문에 보안면에서 취약하기에 중요정보는 GET보다는 POST방식으로 사용한다.
  ```
  ```
  -POST 
  이는 캐시가 불가능하며 자유로운 형식이며 히스토리에 남지 않는다.
  이는 따로 BODY가 있으며 결과 값은 항상 변동된다. 
  이는 데이터를 통해 리소스를 생성하거나 갱신한다.
  ```
  - 그렇다면 GET에서 많은 요청을 보내야 할 때에는 어떻게 사용해야 할까? 
    - 일방적으로는 POST로 변환하여서 전송을 하는게 올바른 구조이다. 하지만 GET방식으로 데이터를 여러개를 받아야 한다면 같은 input name에 여러개를 삽입하여 배열형태로 주고받으면 된다.


#### JWT 
![image](https://media.vlpt.us/images/dnjscksdn98/post/93750576-b681-4658-ba88-10922ffb4ff3/jwt.png)
  - JWT는 Header, Payload, Signature의 3 부분으로 이루어지며, JSON 형태인 각 부분은 Base64로 인코딩 되어 표현된다. 또한 각각의 부분을 이어 주기 위해 . 구분자를 사용하여 구분한다. 추가로 Base64는 암호화된 문자열이 아니고, 같은 문자열에 대해 항상 같은 인코딩 문자열을 반환한다.
  ```
  Header 
  - JWT의 토큰 타입과, 해싱 알고리즘을 정한다. 해싱 알고리즘이란 솔트하는 과정이라고 생각하면 된다.
  Payload 
  - 토큰에 담을 정보가 들어있는 곳, 이는 리퀘스트 파라미터처럼 Json형태의 Key와 Value로 이루어져 있다.
  Signature
  - 토큰을 인코딩하거나 검증할때 사용하는 암호화코드이다. 이를통해서 해싱과 인코딩을 할 수 있다.
  ```
  - 쿠키를 전달하지 않아도 되므로 쿠키를 사용함으로써 발생하는 취약점이 사라집니다.
  - 단 페이로드가 너무 크기에 담고있는 정보가 많아지면 네트워크 부하를 줄 수도 있다.
  - 만료기간을 주지않으면 토큰을 핸들링 할 수 없어서 만료기간을 항상 주어야 한다.
  - 제공된 이후부터는 서버단의 관리에서 벗어나기에 클라이언트에서만 관리할 수 있다.
